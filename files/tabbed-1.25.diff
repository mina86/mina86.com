--- tabbed-1.25.txt	2009-05-16 22:25:29.000000000 +0200
+++ tabbed-patched	2009-05-16 22:25:51.000000000 +0200
@@ -1,40 +1,105 @@
 #! perl
 
+##
+## Tabbed plugin for rxvt-unicode
+## Modified by Michal Nazarewicz (mina86/AT/mina86.com)
+##
+## The following has been added:
+##
+## 1. Depending on time of last activity, activity character differs.
+##    By default, after 4 seconds an asterisk becomes a plus sing,
+##    after next 4 it becomes a colon, and finally, after another 8
+##    seconds it becomes a dot.  This can be configured via
+##    tabbar-timeouts resource.  It's format is:
+##
+##      ( <timeout> ":" <character> ":" )* <timeout> ":" <character> ":"
+##
+##    where <timeout> is timeout in seconds and <character> is
+##    a single activity character.
+##
+## 2. The "[NEW]" button can be disabled (who on Earth uses mouse to
+##    create new tab anyways?) by setting new-button resource to yes.
+##
+## 3. If title resource is true, tab's title is displayed after last
+##    button.  This is handy if you have terminal with no window
+##    decorations.  Colours can be configured via title-fg and
+##    title-bg.
+##
+## 4. Incorporated Alexey Semenko <asemenko at gmail.com> patch adding
+##    autohide resource.  If it's true tab bar is hidden if there is
+##    no more then one tab opened.
+##
+## 5. Tabs are indexed in starting with zero hex. :] If you're such
+##    a geek to use urxvt it shouldn't be a problem for you and it
+##    saves few character when many tabs are opened.
+##
+## 6. As a minor modification: Final pipe character is removed (unless
+##    title is displayed).  This make tab bar look nicer.
+##
+
+
+sub tab_activity_mark ($$) {
+   my ($self, $tab) = @_;
+   return ' ' unless defined $tab->{lastActivity};
+   return ' ' if $tab == $self->{cur};
+   if (defined $self->{timeouts}) {
+      my $diff = int urxvt::NOW - $tab->{lastActivity};
+      for my $spec (@{ $self->{timeouts} }) {
+         return $spec->[1] if $diff > $spec->[0];
+      }
+   }
+   '*';
+}
+
+
 sub refresh {
    my ($self) = @_;
 
+   # autohide makes it zero
+   return unless $self->{tabheight};
+
    my $ncol = $self->ncol;
 
    my $text = " " x $ncol;
    my $rend = [($self->{rs_tabbar}) x $ncol];
 
-   my @ofs;
+   my ($ofs, $idx, @ofs) = (0, 0);
 
-   substr $text, 0, 7, "[NEW] |";
-   @$rend[0 .. 5] = ($self->{rs_tab}) x 6;
-   push @ofs, [0, 6, sub { $_[0]->new_tab }];
-
-   my $ofs = 7;
-   my $idx = 0;
+   if ($self->{new_button}) {
+      substr $text, 0, 7, "[NEW] |";
+      @$rend[0 .. 5] = ($self->{rs_tab}) x 6;
+      push @ofs, [0, 6, -1 ];
+      $ofs = 7;
+   }
 
    for my $tab (@{ $self->{tabs} }) {
-      $idx++;
-
-      my $act = $tab->{activity} && $tab != $self->{cur}
-                ? "*" : " ";
-
-      my $txt = "$act$idx$act";
+      my $act = $self->tab_activity_mark($tab);
+      my $txt = sprintf "%s%x%s", $act, $idx, $act;
       my $len = length $txt;
 
       substr $text, $ofs, $len + 1, "$txt|";
       @$rend[$ofs .. $ofs + $len - 1] = ($self->{rs_tab}) x $len
          if $tab == $self->{cur};
 
-      push @ofs, [ $ofs, $ofs + $len, sub { $_[0]->make_current ($tab) } ];
-
+      push @ofs, [ $ofs, $ofs + $len, $idx ];
+      ++$idx;
       $ofs += $len + 1;
    }
 
+   substr $text, --$ofs, 1, ' '; # remove last '|'
+
+   if ($self->{tab_title} && $ofs + 3 < $ncol) {
+      my $term = $self->{term};
+      my @str = $term->XGetWindowProperty($term->parent, $self->{tab_title});
+      if (@str && $str[2]) {
+         my $str = '| ' . $str[2];
+         my $len = length $str;
+         $len = $ncol - $ofs if $ofs + $len > $ncol;
+         substr $text, $ofs, $len, substr $str, 0, $len;
+         @$rend[$ofs + 2 .. $ofs + $len - 1] = ($self->{rs_title}) x ($len - 2);
+      }
+   }
+
    $self->{tabofs} = \@ofs;
 
    $self->ROW_t (0, $text, 0, 0, $ncol);
@@ -43,11 +108,15 @@
    $self->want_refresh;
 }
 
+
 sub new_tab {
    my ($self, @argv) = @_;
 
    my $offset = $self->fheight;
 
+   $self->{tabheight} = $self->{maxtabheight}
+   unless $self->{autohide} && !(defined $self->{tabs} && @{ $self->{tabs} });
+
    # save a backlink to us, make sure tabbed is inactive
    push @urxvt::TERM_INIT, sub {
       my ($term) = @_;
@@ -68,10 +137,10 @@
    my $term = new urxvt::term
       $self->env, $urxvt::RXVTNAME,
       -embed => $self->parent,
-      @argv,
-   ;
+      @argv;
 }
 
+
 sub configure {
    my ($self) = @_;
 
@@ -90,11 +159,6 @@
    );
 }
 
-sub on_resize_all_windows {
-   my ($self, $width, $height) = @_;
-
-   1
-}
 
 sub copy_properties {
    my ($self) = @_;
@@ -107,13 +171,13 @@
    # pass 1: copy over properties different or nonexisting
    for my $atom ($tab->XListProperties ($tab->parent)) {
       my ($type, $format, $items) = $self->XGetWindowProperty ($tab->parent, $atom);
-      
+
       # fix up size hints
       if ($atom == $wm_normal_hints) {
          my (@hints) = unpack "l!*", $items;
-      
+
          $hints[$_] += $self->{tabheight} for (4, 6, 16);
-      
+
          $items = pack "l!*", @hints;
       }
 
@@ -130,82 +194,74 @@
    $self->XDeleteProperty ($self->parent, $_) for keys %$current;
 }
 
+
 sub make_current {
    my ($self, $tab) = @_;
 
    if (my $cur = $self->{cur}) {
-      delete $cur->{activity};
+      delete $cur->{lastActivity};
       $cur->XUnmapWindow ($cur->parent) if $cur->mapped;
       $cur->focus_out;
    }
-   
+
    $self->{cur} = $tab;
 
    $self->configure;
    $self->copy_properties;
-   
+
    $tab->focus_out; # just in case, should be a nop
    $tab->focus_in if $self->focus;
-   
+
    $tab->XMapWindow ($tab->parent);
-   delete $tab->{activity};
+   delete $tab->{lastActivity};
    $self->refresh;
 
-   ()
+   ();
 }
 
+
 sub on_focus_in {
    my ($self, $event) = @_;
-
    $self->{cur}->focus_in;
-
-   ()
+   ();
 }
 
 sub on_focus_out {
    my ($self, $event) = @_;
-
    $self->{cur}->focus_out;
-
-   ()
+   ();
 }
 
 sub on_key_press {
    my ($self, $event) = @_;
-
    $self->{cur}->key_press ($event->{state}, $event->{keycode}, $event->{time});
-
-   1
+   1;
 }
 
 sub on_key_release {
    my ($self, $event) = @_;
-
    $self->{cur}->key_release ($event->{state}, $event->{keycode}, $event->{time});
-
-   1
-}
-
-sub on_button_press {
-   1
+   1;
 }
 
 sub on_button_release {
    my ($self, $event) = @_;
 
    if ($event->{row} == 0) {
+      my $col = $event->{col};
       for my $button (@{ $self->{tabofs} }) {
-         $button->[2]->($self, $event)
-            if $event->{col} >= $button->[0]
-               && $event->{col} < $button->[1];
+         last if     $col <  $button->[0];
+         next unless $col <= $button->[1];
+         if ($button->[2] == -1) {
+            $self->new_tab;
+         } else {
+            $self->make_current($self->{tabs}[$button->[2]]);
+         }
       }
+      return 1;
    }
 
-   1
-}
-
-sub on_motion_notify {
-   1
+   ();
 }
 
 sub on_init {
@@ -223,22 +279,50 @@
    my $bg    = $self->x_resource ("tabbar-bg");
    my $tabfg = $self->x_resource ("tab-fg");
    my $tabbg = $self->x_resource ("tab-bg");
+   my $titfg = $self->x_resource ("title-fg");
+   my $titbg = $self->x_resource ("title-bg");
 
    defined $fg    or $fg    = 3;
    defined $bg    or $bg    = 0;
    defined $tabfg or $tabfg = 0;
    defined $tabbg or $tabbg = 1;
+   defined $titfg or $titfg = 2;
+   defined $titbg or $titbg = 0;
 
    $self->{rs_tabbar} = urxvt::SET_COLOR (urxvt::DEFAULT_RSTYLE, $fg    + 2, $bg    + 2);
    $self->{rs_tab}    = urxvt::SET_COLOR (urxvt::DEFAULT_RSTYLE, $tabfg + 2, $tabbg + 2);
+   $self->{rs_title}  = urxvt::SET_COLOR (urxvt::DEFAULT_RSTYLE, $titfg + 2, $titbg + 2);
 
-   ()
+
+   my $timeouts = $self->x_resource ("tabbar-timeouts");
+   $timeouts = '16:.:8:::4:+' unless defined $timeouts;
+   if ($timeouts ne '') {
+      my @timeouts;
+      while ($timeouts =~ /^(\d+):(.)(?::(.*))?$/) {
+         push @timeouts, [ int $1, $2 ];
+         $timeouts = defined $3 ? $3 : '';
+      }
+      if (@timeouts) {
+         $self->{timeouts} = [ sort { $b->[0] <=> $a-> [0] } @timeouts ];
+      }
+   }
+
+   $self->{new_button} =
+      ($self->x_resource ('new-button') or 'true') !~ /^(?:false|0|no)/i;
+   $self->{tab_title} =
+      ($self->x_resource ('title') or 'true') !~ /^(?:false|0|no)/i;
+   $self->{autohide} =
+      ($self->x_resource ('autohide') or 'false') !~ /^(?:false|0|no)/i;
+
+   ();
 }
 
+
 sub on_start {
    my ($self) = @_;
 
-   $self->{tabheight} = $self->int_bwidth + $self->fheight + $self->lineSpace;
+   $self->{maxtabheight} = $self->int_bwidth + $self->fheight + $self->lineSpace;
+   $self->{tabheight} = $self->{autohide} ? 0 : $self->{maxtabheight};
 
    $self->cmd_parse ("\033[?25l");
 
@@ -248,28 +332,41 @@
       shift @argv;
    } while @argv && $argv[0] ne "-e";
 
+   if ($self->{tab_title}) {
+      $self->{tab_title} = $self->{term}->XInternAtom("WM_NAME", 1);
+   }
+
    $self->new_tab (@argv);
 
-   ()
+   if (defined $self->{timeouts}) {
+      my $interval = ($self->{timeouts}[@{ $self->{timeouts} } - 1]->[0]);
+      $interval = int($interval / 4);
+      $self->{timer} = urxvt::timer->new
+                                   ->interval($interval < 1 ? 1 : $interval)
+                                   ->cb ( sub { $self->refresh; } );
+   }
+
+   ();
 }
 
+
 sub on_configure_notify {
    my ($self, $event) = @_;
 
    $self->configure;
    $self->refresh;
 
-   ()
+   ();
 }
 
+
 sub on_wm_delete_window {
    my ($self) = @_;
-
    $_->destroy for @{ $self->{tabs} };
-
-   1
+   1;
 }
 
+
 sub tab_start {
    my ($self, $tab) = @_;
 
@@ -280,13 +377,15 @@
 #   $tab->{name} ||= scalar @{ $self->{tabs} };
    $self->make_current ($tab);
 
-   ()
+   ();
 }
 
+
 sub tab_destroy {
    my ($self, $tab) = @_;
 
    $self->{tabs} = [ grep $_ != $tab, @{ $self->{tabs} } ];
+   $self->{tabheight} = 0 if $self->{autohide} && @{ $self->{tabs} } <= 1;
 
    if (@{ $self->{tabs} }) {
       if ($self->{cur} == $tab) {
@@ -300,67 +399,73 @@
       $self->{destroy} = urxvt::iw->new->start->cb (sub { $self->destroy });
    }
 
-   ()
+   ();
 }
 
+
 sub tab_key_press {
    my ($self, $tab, $event, $keysym, $str) = @_;
 
    if ($event->{state} & urxvt::ShiftMask) {
       if ($keysym == 0xff51 || $keysym == 0xff53) {
-         my ($idx) = grep $self->{tabs}[$_] == $tab, 0 .. $#{ $self->{tabs} };
-
-         --$idx if $keysym == 0xff51;
-         ++$idx if $keysym == 0xff53;
-
-         $self->make_current ($self->{tabs}[$idx % @{ $self->{tabs}}]);
-         
+         if (@{ $self->{tabs} } > 1) {
+            my $idx = 0;
+            ++$idx while $self->{tabs}[$idx] != $tab;
+            $idx += $keysym - 0xff52;
+            $self->make_current ($self->{tabs}[$idx % @{ $self->{tabs}}]);
+         }
          return 1;
+
       } elsif ($keysym == 0xff54) {
          $self->new_tab;
-
          return 1;
       }
-   }
-   elsif ($event->{state} & urxvt::ControlMask) {
+   } elsif ($event->{state} & urxvt::ControlMask) {
       if ($keysym == 0xff51 || $keysym == 0xff53) {
-         my ($idx1) = grep $self->{tabs}[$_] == $tab, 0 .. $#{ $self->{tabs} };
-         my  $idx2  = ($idx1 + ($keysym == 0xff51 ? -1 : +1)) % @{ $self->{tabs} };
-
-         ($self->{tabs}[$idx1], $self->{tabs}[$idx2]) =
-            ($self->{tabs}[$idx2], $self->{tabs}[$idx1]);
-
-         $self->make_current ($self->{tabs}[$idx2]);
-
+         if (@{ $self->{tabs} } > 1) {
+            my $idx1 = 0;
+            ++$idx1 while $self->{tabs}[$idx1] != $tab;
+            my $idx2 = ($idx1 + $keysym - 0xff52) % @{ $self->{tabs} };
+
+            ($self->{tabs}[$idx1], $self->{tabs}[$idx2]) =
+                ($self->{tabs}[$idx2], $self->{tabs}[$idx1]);
+            $self->make_current ($self->{tabs}[$idx2]);
+         }
          return 1;
       }
    }
 
-   ()
+   ();
 }
 
+
 sub tab_property_notify {
    my ($self, $tab, $event) = @_;
 
    $self->copy_properties
       if $event->{window} == $tab->parent;
 
-   ()
+   ();
 }
 
-sub tab_activity {
-   my ($self, $tab) = @_;
 
-   $self->refresh;
+sub tab_add_lines {
+   my ($self, $tab) = @_;
+   my $mark = $self->tab_activity_mark($tab);
+   $tab->{lastActivity} = int urxvt::NOW;
+   $self->refresh if $mark ne $self->tab_activity_mark($tab);
+   ();
 }
 
+
+
 package urxvt::ext::tabbed::tab;
 
 # helper extension implementing the subwindows of a tabbed terminal.
 # simply proxies all interesting calls back to the tabbed class.
 
 {
-   for my $hook qw(start destroy key_press property_notify) {
+   for my $hook qw(start destroy key_press property_notify add_lines) {
       eval qq{
          sub on_$hook {
             my \$parent = \$_[0]{term}{parent}
@@ -371,11 +476,3 @@
       die if $@;
    }
 }
-
-sub on_add_lines {
-  $_[0]->{activity}++
-     or $_[0]{term}{parent}->tab_activity ($_[0]);
-  ()
-}
-
-
