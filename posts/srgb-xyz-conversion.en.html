<!-- subject: sRGB↔XYZ conversion -->
<!-- date: 2019-07-07 17:25:42 -->
<!-- update: 2021-03-21 01:21:33 -->
<!-- tags: rgb, srgb, colorimetry -->
<!-- categories: Articles, Techblog -->
<!-- math: true -->

<p>In an earlier post, I’ve shown how
  to <a href="/2019/srgb-xyz-matrix/">calculate an sRGB↔XYZ conversion
  matrix</a>.  It’s only natural to follow up with a code for converting
  between <a href="https://en.wikipedia.org/wiki/SRGB">sRGB</a>
  and <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">XYZ</a>
  colour spaces.  While the matrix is a significant portion of the algorithm,
  there is one more step necessary: gamma correction.


<h2>What is gamma correction?</h2>

<p>Human perception of light’s brightness
  approximates <a href="https://en.wikipedia.org/wiki/Stevens%27s_power_law">a power
  function</a> of its intensity.  This can be expressed as \(P = S^\alpha\)
  where \(P\) is the perceived brightness and \(S\) is linear intensity.
  \(\alpha\) has been experimentally measured to be less than one which means
  that people are more sensitive to changes to dark colours rather than to
  bright ones.

<p>Based on that observation, colour space’s encoding can be made more efficient
  by using higher precision when encoding dark colours and lower when encoding
  bright ones.  This is akin to precision of floating-point numbers scaling with
  value’s magnitude.  In RGB systems, the role of precision scaling is done
  by <dfn>gamma correction</dfn>.  When colour is captured (for example from
  a digital camera) it goes through <dfn>gamma compression</dfn> which spaces
  dark colours apart and packs lighter colours more densely.  When displaying an
  image, the opposite happens and encoded value goes through <dfn>gamma
  expansion</dfn>.

<!-- EXCERPT -->

<figure style="float: right; margin: 1em">
  <svg width="4.5em" height="16.5em" viewBox="0 0 3 11" fill="#000">
    <style>
      text { text-anchor: end }
    </style>
    <path d="M0,0  h2 v1 h-2 z" fill="#0f0"    />
    <path d="M0,1  h1 v1 h-1 z" fill="#00e500" />
    <path d="M0,2  h1 v1 h-1 z" fill="#0c0"    />
    <path d="M0,3  h1 v1 h-1 z" fill="#00b200" />
    <path d="M0,4  h1 v1 h-1 z" fill="#090"    />
    <path d="M0,5  h1 v1 h-1 z" fill="#007f00" />
    <path d="M0,6  h1 v1 h-1 z" fill="#060"    />
    <path d="M0,7  h1 v1 h-1 z" fill="#004c00" />
    <path d="M0,8  h1 v1 h-1 z" fill="#030"    />
    <path d="M0,9  h1 v1 h-1 z" fill="#001a00" />
    <path d="M0,10 h2 v1 h-2 z" fill="#000"    />

    <g transform="translate(1)">
      <path fill="#00f200" d="M0,1 h1 v1 h-1 z" />
      <path fill="#00e800" d="M0,2 h1 v1 h-1 z" />
      <path fill="#00d900" d="M0,3 h1 v1 h-1 z" />
      <path fill="#0c0"    d="M0,4 h1 v1 h-1 z" />
      <path fill="#00bd00" d="M0,5 h1 v1 h-1 z" />
      <path fill="#00ab00" d="M0,6 h1 v1 h-1 z" />
      <path fill="#009400" d="M0,7 h1 v1 h-1 z" />
      <path fill="#007a00" d="M0,8 h1 v1 h-1 z" />
      <path fill="#005900" d="M0,9 h1 v1 h-1 z" />
    </g>

    <g transform="translate(3,.6)" font-size=".4">
      <text       >1.0</text>
      <text y="1" >0.9</text>
      <text y="2" >0.8</text>
      <text y="3" >0.7</text>
      <text y="4" >0.6</text>
      <text y="5" >0.5</text>
      <text y="6" >0.4</text>
      <text y="7" >0.3</text>
      <text y="8" >0.2</text>
      <text y="9" >0.1</text>
      <text y="10">0.0</text>
    </g>

    <g transform="rotate(-90)" font-size=".5">
      <text x="-.3" y=".6">Encoded</text>
      <text x="-.3" y="1.8">Intensity</text>
    </g>
  </svg>
</figure>

<p>Many RGB systems use a simple \(S = E^\gamma\) expansion formula, where \(E\)
  is the encoded (or non-linear) value.  With decoding \(\gamma\) approximating
  \(1/\alpha\), equal steps in encoding space correspond roughly to equal steps
  in perceived brightness.  Image on the right demonstrates this by comparing
  two colour gradients.  The first one has been generated by increasing encoded
  value in equal steps and the second one has been created by doing the same to
  light intensity.  The former includes many dark colours while the latter
  contains a sudden jump in brightness from black to the next colour.

<p>sRGB uses slightly more complicated formula stitching together two functions:

  $$ \begin{align}
    E &= \begin{cases}
      12.92 × S                 & \text{if } S ≤ S_0 \\
      1.055 × S^{1/2.4} - 0.055 & \text{otherwise}
    \end{cases} \\[.5em]
    S &= \begin{cases}
      {E \over 12.92}                            & \text{if } E ≤ E_0 \\
      \left({E + 0.055 \over 1.055}\right)^{2.4} & \text{otherwise}
    \end{cases} \\[.5em]
    S_0 &= 0.00313066844250060782371 \\
    E_0 &= 12.92 × S_0 \\
        &= 0.04044823627710785308233
  \end{align} $$

<p>The formulæ assume values are normalised to [0, 1] range.  This is not
  always how they are expressed so a scaling step might be necessary.


<h2>sRGB encoding</h2>

<p>Most common sRGB encoding
  uses <a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">eight
  bits per channel</a> which introduces a scaling step: \(E_8 = ⌊E × 255⌉\).  In
  an actual implementation, to increase efficiency and accuracy of gamma
  operations, it’s best to <em>fuse</em> the multiplication into aforementioned
  formulæ.  With that arguably obvious optimisation, the equations become:

  $$ \begin{align}
    E_8 &= \begin{cases}
      ⌊3294.6 × S⌉                   & \text{if } S ≤ S_0 \\
      ⌊269.025 × S^{1/2.4} - 14.025⌉ & \text{otherwise}
    \end{cases} \\[.5em]
    S &= \begin{cases}
      {E_8 \over 3294.6}                              & \text{if } E_8 ≤ 10 \\
      \left({E_8 + 14.025 \over 269.025}\right)^{2.4} & \text{otherwise}
    \end{cases} \\[.5em]
    S_0 &= 0.00313066844250060782371 \\
  \end{align} $$

<p>This isn’t the only way to represent colours of course.  For example, 10-bit
  colour depth changes the scaling factor to 1024;
  16-bit <a href="https://en.wikipedia.org/wiki/High_color">high colour</a> uses
  five bits for red and blue channels while five or six for green producing
  different scaling factors for different primaries; and HDTV caps the range to
  [16, 235].  Needless to say, correct formulæ need to be chosen based on the
  standard in question.


<h2>The implementation</h2>

<p>And that’s it.  Encoding, gamma correction
  and <a href="/2019/srgb-xyz-matrix/">the conversion matrix</a> are all the
  necessary pieces to get the conversion implemented.  To keep things
  interesting, lets this time write the code in TypeScript:

<pre>
<!-- INCLUDE ESCAPED: srgb-xyz-conversion.ts -->
</pre>


<style>
#demo td                 { text-align: center; }
#demo input[type=number] { width: 7em; }
</style>
<form id=demo style="display:none" novalidate>
  <h2>Demonstration</h2>

  <p>And finally, for demonstration, the form below allows converting between
  sRGB colours and their XYZ coordinates.  The table allows entry and performs
  automatic conversion between non-linear and linear red, green and blue
  values.  Observing how they relate to each other may help visualise the
  effects of gamma correction.

  <table>
    <tbody>
      <tr>
        <th scope=row>Colour
        <td colspan=3><input type=color name=c value="#FFFFFF">
        <td><code>#RRGGBB</code>
    <tbody>
      <tr><td><th scope=col>Red<th scope=col>Green<th scope=col>Blue<td>
      <tr>
        <th scope=row>8-bit encoded
        <td><input type=number name=r8 value=255>
        <td><input type=number name=g8 value=255>
        <td><input type=number name=b8 value=255>
        <td>Non-linear in [0, 255] range
      <tr>
        <th scope=row>Compressed
        <td><input type=number name=r step=0.001 value=1.0>
        <td><input type=number name=g step=0.001 value=1.0>
        <td><input type=number name=b step=0.001 value=1.0>
        <td>Non-linear in [0, 1] range
      <tr>
        <th scope=row>Expanded
        <td><input type=number name=lr step=0.001 value=1.0>
        <td><input type=number name=lg step=0.001 value=1.0>
        <td><input type=number name=lb step=0.001 value=1.0>
        <td>Linear in [0, 1] range
    <tbody>
      <tr><td><th scope=col>X<th scope=col>Y<th scope=col>Z<td>
      <tr>
        <td>
        <td><input type=number name=x step=0.001 value=0.95 >
        <td><input type=number name=y step=0.001 value=1    >
        <td><input type=number name=z step=0.001 value=1.089>
        <td>
  </table>
</form>

<script src=/d/srgb-xyz-conversion-demo.js></script>

<p>Update (March 2021): The implementation has been updated with more precise
  value for the D65 standard illuminant.  This affected values
  in <code>xyzFromRgbMatrix</code> and <code>rgbFromXyzMatrix</code> matrices..
